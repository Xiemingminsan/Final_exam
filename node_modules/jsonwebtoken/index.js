const crypto = require('crypto')

function base64url(input) {
  return Buffer.from(input).toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_')
}

function parseTimespan(span) {
  if (typeof span === 'number') return span
  const match = /^([0-9]+)([smhd])$/.exec(span)
  if (!match) return parseInt(span, 10) || 0
  const value = parseInt(match[1], 10)
  const unit = match[2]
  const map = { s: 1, m: 60, h: 3600, d: 86400 }
  return value * (map[unit] || 1)
}

function sign(payload, secret, options = {}) {
  const header = { alg: 'HS256', typ: 'JWT' }
  const exp = options.expiresIn ? Math.floor(Date.now() / 1000) + parseTimespan(options.expiresIn) : undefined
  const body = exp ? { ...payload, exp } : { ...payload }
  const headerEncoded = base64url(JSON.stringify(header))
  const payloadEncoded = base64url(JSON.stringify(body))
  const data = `${headerEncoded}.${payloadEncoded}`
  const signature = crypto.createHmac('sha256', secret).update(data).digest('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_')
  return `${data}.${signature}`
}

function verify(token, secret) {
  const parts = token.split('.')
  if (parts.length !== 3) throw new Error('Invalid token')
  const [header, payload, signature] = parts
  const data = `${header}.${payload}`
  const expected = crypto.createHmac('sha256', secret).update(data).digest('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_')
  if (expected !== signature) throw new Error('Invalid signature')
  const payloadObj = JSON.parse(Buffer.from(payload, 'base64').toString())
  if (payloadObj.exp && Math.floor(Date.now() / 1000) >= payloadObj.exp) throw new Error('Token expired')
  return payloadObj
}

module.exports = { sign, verify }
