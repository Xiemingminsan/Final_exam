const fs = require('fs')
const path = require('path')

class Sequelize {
  constructor(database, username, password, options = {}) {
    if (typeof database === 'object') {
      options = database
    } else if (typeof username === 'object') {
      options = username
    }
    this.options = options
    this.models = {}
    const storageDir = path.join(process.cwd(), 'data')
    if (!fs.existsSync(storageDir)) fs.mkdirSync(storageDir, { recursive: true })
    this.storage = options.storage || path.join(storageDir, 'database.json')
    this._load()
  }

  _load() {
    if (fs.existsSync(this.storage)) {
      const raw = fs.readFileSync(this.storage, 'utf8')
      try {
        const parsed = JSON.parse(raw)
        this.data = parsed.data || {}
        this.counters = parsed.counters || {}
      } catch (error) {
        this.data = {}
        this.counters = {}
      }
    } else {
      this.data = {}
      this.counters = {}
    }
  }

  _save() {
    const payload = JSON.stringify({ data: this.data, counters: this.counters }, null, 2)
    fs.writeFileSync(this.storage, payload)
  }

  async sync() {
    this._save()
  }

  define(name, attributes) {
    const sequelize = this
    if (!this.data[name]) this.data[name] = []
    if (!this.counters[name]) this.counters[name] = 1
    class Model {
      static get name() {
        return name
      }
      static get rawAttributes() {
        return attributes
      }
      static _getStore() {
        return sequelize.data[name]
      }
      static _wrap(record) {
        if (!record) return null
        return { ...record }
      }
      static _matches(record, where = {}) {
        return Object.entries(where).every(([key, value]) => {
          if (value && typeof value === 'object' && value.$in) return value.$in.includes(record[key])
          return record[key] === value
        })
      }
      static async create(values) {
        const store = this._getStore()
        const record = { id: sequelize.counters[name]++, ...values }
        store.push(record)
        sequelize._save()
        return this._wrap(record)
      }
      static async findOne(options = {}) {
        const { where } = options
        const store = this._getStore()
        const record = store.find(item => this._matches(item, where || {}))
        return this._wrap(record)
      }
      static async findByPk(id) {
        const store = this._getStore()
        const record = store.find(item => item.id == id)
        return this._wrap(record)
      }
      static async findAll(options = {}) {
        const { where = {}, limit, offset = 0, attributes: attrs, order } = options
        let results = this._getStore().filter(item => this._matches(item, where))
        if (order && Array.isArray(order) && order.length > 0) {
          const [field, direction] = order[0]
          results = results.sort((a, b) => {
            if (a[field] < b[field]) return direction === 'DESC' ? 1 : -1
            if (a[field] > b[field]) return direction === 'DESC' ? -1 : 1
            return 0
          })
        }
        if (typeof offset === 'number' && offset > 0) results = results.slice(offset)
        if (typeof limit === 'number') results = results.slice(0, limit)
        if (Array.isArray(attrs) && attrs.length > 0) {
          results = results.map(item => {
            const subset = {}
            for (const key of attrs) subset[key] = item[key]
            return subset
          })
        } else {
          results = results.map(item => this._wrap(item))
        }
        return results
      }
      static async count(options = {}) {
        const { where = {} } = options
        const store = this._getStore()
        return store.filter(item => this._matches(item, where)).length
      }
      static async update(values, options = {}) {
        const { where = {} } = options
        const store = this._getStore()
        let count = 0
        for (const item of store) {
          if (this._matches(item, where)) {
            Object.assign(item, values)
            count++
          }
        }
        if (count > 0) sequelize._save()
        return [count]
      }
      static async destroy(options = {}) {
        const { where = {} } = options
        const store = this._getStore()
        const originalLength = store.length
        const remaining = store.filter(item => !this._matches(item, where))
        this.data = remaining
        sequelize.data[name] = remaining
        const count = originalLength - remaining.length
        if (count > 0) sequelize._save()
        return count
      }
      static belongsTo(target, options = {}) {
        if (!this.associations) this.associations = {}
        this.associations[options.foreignKey || `${target.name}Id`] = target
      }
      static hasMany(target, options = {}) {
        if (!this.associations) this.associations = {}
        this.associations[options.foreignKey || `${this.name}Id`] = target
      }
    }
    Model.sequelize = sequelize
    sequelize.models[name] = Model
    return Model
  }
}

const DataTypes = {
  STRING: 'string',
  INTEGER: 'number'
}

module.exports = { Sequelize, DataTypes }
