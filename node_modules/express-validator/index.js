function body(field) {
  const validations = []
  let lastEntry = null
  const middleware = (req, res, next) => {
    const value = req.body ? req.body[field] : undefined
    for (const entry of validations) {
      let passed = true
      try {
        passed = entry.fn(value, req)
      } catch (error) {
        passed = false
      }
      if (!passed) {
        if (!req._validationErrors) req._validationErrors = []
        req._validationErrors.push({ msg: entry.message || 'Invalid value', param: field })
      }
    }
    next()
  }
  const add = (fn, message) => {
    lastEntry = { fn, message }
    validations.push(lastEntry)
    return middleware
  }
  middleware.withMessage = message => {
    if (lastEntry) lastEntry.message = message
    return middleware
  }
  middleware.notEmpty = () => add(value => !(value === undefined || value === null || value === ''), 'Invalid value')
  middleware.isEmail = () => add(value => /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(String(value || '')), 'Invalid email')
  middleware.isLength = options => {
    const { min = 0, max = Infinity } = options || {}
    return add(value => {
      const length = value ? String(value).length : 0
      if (length < min) return false
      if (max !== Infinity && length > max) return false
      return true
    }, 'Invalid length')
  }
  middleware.isString = () => add(value => typeof value === 'string', 'Invalid value')
  middleware.isAlphanumeric = () => add(value => /^[a-z0-9]+$/i.test(String(value || '')), 'Invalid value')
  middleware.custom = fn => add((value, req) => fn(value, { req }), 'Invalid value')
  return middleware
}

function validationResult(req) {
  const errors = req._validationErrors || []
  return {
    isEmpty: () => errors.length === 0,
    array: () => errors
  }
}

module.exports = { body, validationResult }
